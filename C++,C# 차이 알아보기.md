C++과 C#의 차이점
=================

| 분류 내용 | C++ | C# |
|:---: |:---:|:---:|
| 컴파일 | 바이너리로 직접 변환 | 바이트코드로 변환 |
| 컴파일 시간 | 긴 컴파일 시간 | 짧은 컴파일 시간 |
| 메모리 관리 | 수동, 스마트 포인터를 사용해 반자동 관리 | 가비지 콜렉터를 사용한 자동 관리 |
| 런타임속도 | 빠름 | C++보다 느림 |
| 런타임 메모리 요구사항 | 최적 | C++보다 많음 |
| Gc와 스마트포인터 | 댕글링 포인터나 스마트포인터 | 가비지 컬렉터 |
| 의도하지 않은 오류	| 경험이 없는 프로그래머에게는 오류가 발생하기 쉬움	| C++보다 초보자 친화적 | 
| 클래스 상속	| 단일, 다중 및 가상 | 단일, 인터페이스 | 
| 제네릭 코드	| 템플릿 – 컴파일 도중	| 제네릭 – 런타임 도중 | 
| 이식성 | 거의 모든 운영체제에서 사용할 수 있음 <br> 그러나 모든 운영체제 별로 컴파일을 일일이 해야 함	| 컴파일된 바이트코드는 많은 운영체제에서 실행될 수 있음 | 
| 리플렉션	| 사용할 수 없음 ( .net framwork 6.0버전부터는 지원하는것 같음 ) <br> 런타임 유형 정보는 리플렉션 보다 사용성이 떨어짐	| 사용 가능하고 매우 편리함 | 
| 암시적 형 변환	| 내장 유형에 대해 허용됨	| 안전한 경우에만 허용됨 | 
| 모듈화	| 라이브러리 및 헤더를 이용해 가능함 | 언어에 내장되지 있음 | 
| CLASS와 STRUCT의 차이	| CLASS는 접근제한자가 기본적으로 PRIVATE STRUCT PUBLIC | CLASS는 상속 O 힙영역, 얕은복사 <br> STRUCT는 상속 X 스택영역 깊은복사<br> 단 STRUCT도 일정크기 넘으면 힙영역에 할당됨 <br> REF로 얕은복사 일어나게 할 수 있음. <br> READONLY로 변경 불가능한 객체를 만들수있음 |


